<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Pro Concept Map Builder — Enhanced</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap');

    :root {
      --bg: #0c173a;
      --panel-bg: #14284f;
      --accent: #60a5fa;
      --text: #e4ebff;
      --muted: #7a9acd;
      --shadow: rgba(92, 160, 250, 0.45);
      --grid: rgba(96, 165, 250, 0.12);
      --spacing: 12px;
    }

    * {
      box-sizing: border-box;
    }

    html,
    body {
      height: 100%;
      margin: 0;
      font-family: 'Inter', sans-serif;
      background: var(--bg);
      color: var(--text);
      user-select: none;
    }

    .app {
      height: 100%;
      display: flex;
      flex-direction: column;
    }

    header {
      height: 56px;
      background: var(--panel-bg);
      display: flex;
      align-items: center;
      padding: 0 var(--spacing);
      border-bottom: 1px solid #223e78;
      box-shadow: 0 0 12px var(--shadow);
    }

    header h1 {
      font-size: 18px;
      font-weight: 700;
      flex: 1;
    }

    .toolbar button {
      margin-left: 8px;
      background: transparent;
      border: 1.5px solid var(--accent);
      color: var(--accent);
      font-weight: 600;
      font-size: 13px;
      padding: 6px 12px;
      border-radius: 12px;
      cursor: pointer;
    }

    .toolbar .btn-primary {
      background: var(--accent);
      color: var(--bg);
      border: none;
      box-shadow: 0 0 16px var(--accent);
    }

    main {
      flex: 1;
      display: flex;
      gap: var(--spacing);
      padding: var(--spacing);
    }

    .side-panel {
      background: var(--panel-bg);
      border-radius: 16px;
      padding: 16px;
      width: 220px;
      box-shadow: 0 0 24px var(--shadow);
    }

    .inspector {
      width: 300px;
      padding: 16px;
      border-radius: 16px;
      background: var(--panel-bg);
      color: var(--muted);
      box-shadow: 0 0 24px var(--shadow);
    }

    .shape-item {
      display: flex;
      align-items: center;
      padding: 10px 12px;
      border-radius: 12px;
      background: rgba(96, 165, 250, 0.08);
      margin-bottom: 12px;
      font-weight: 700;
      color: var(--accent);
      cursor: grab;
    }

    .shape-item .icon {
      width: 28px;
      height: 28px;
      margin-right: 10px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .canvas-container {
      flex: 1;
      position: relative;
      border-radius: 20px;
      background: #081333;
      box-shadow: inset 0 0 30px #031027;
      overflow: hidden;
      display: flex;
      flex-direction: column;
    }

    #grid {
      position: absolute;
      inset: 0;
      pointer-events: none;
      background-image: linear-gradient(var(--grid) 1px, transparent 1px), linear-gradient(90deg, var(--grid) 1px, transparent 1px);
      background-size: 20px 20px;
    }

    svg#canvas-svg {
      width: 100%;
      height: 100%;
      display: block;
      cursor: default;
    }

    .inspector label {
      display: block;
      margin-top: 12px;
      font-weight: 700;
      color: var(--text);
    }

    .inspector input[type=text],
    .inspector select,
    .inspector input[type=color],
    .inspector input[type=number] {
      margin-top: 6px;
      padding: 8px 10px;
      background: #0d2240;
      border: none;
      border-radius: 10px;
      color: var(--accent);
      font-weight: 700;
    }

    .inspector .actions {
      display: flex;
      gap: 8px;
      margin-top: 12px;
    }

    .context-menu {
      position: fixed;
      background: linear-gradient(180deg, #0f2a52, #081a3a);
      color: var(--text);
      border-radius: 10px;
      padding: 8px;
      box-shadow: 0 6px 24px rgba(0, 0, 0, 0.6);
      display: none;
      z-index: 9999;
    }

    .context-menu button {
      display: block;
      width: 100%;
      text-align: left;
      padding: 8px 12px;
      background: transparent;
      border: none;
      color: var(--text);
      cursor: pointer;
      border-radius: 6px;
    }

    .context-menu button:hover {
      background: rgba(96, 165, 250, 0.08);
    }

    .hidden {
      display: none !important;
    }

    /* resize handle */
    .handle {
      fill: #e4ebff;
      stroke: #0b1b36;
      stroke-width: 1px;
      cursor: nwse-resize;
    }

    .handle.rotate {
      cursor: grab;
    }

    /* small helper */
    .topbar-info {
      font-size: 12px;
      color: var(--muted);
      margin-left: 10px;
    }
  </style>
</head>

<body>
  <div class="app">
    <header>
      <h1>Pro Concept Map Builder</h1>
      <div class="topbar-info">Enhanced — Resize · Connectors · Grouping · Save/Load · Shortcuts</div>
      <nav class="toolbar" aria-label="Toolbar">
        <button id="undo">↶ Undo</button>
        <button id="redo">↷ Redo</button>
        <button id="copy">Copy</button>
        <button id="paste">Paste</button>
        <button id="duplicate">Duplicate</button>
        <button id="deleteSelected">Delete</button>
        <button id="zoomIn">Zoom +</button>
        <button id="zoomOut">Zoom -</button>
        <button id="fit">Fit</button>
        <button id="exportSvg">Export SVG</button>
        <button id="exportPng" class="btn-primary">Export PNG</button>
      </nav>
    </header>

    <main>
      <aside class="side-panel palette" aria-label="Shapes palette">
        <h3 style="color:var(--accent);margin:0 0 12px 0;">Shapes</h3>
        <div class="shape-item" draggable="true" data-shape="rect"><span class="icon">▭</span>Rectangle</div>
        <div class="shape-item" draggable="true" data-shape="ellipse"><span class="icon">⬭</span>Ellipse</div>
        <div class="shape-item" draggable="true" data-shape="circle"><span class="icon">●</span>Circle</div>
        <div class="shape-item" draggable="true" data-shape="diamond"><span class="icon">◇</span>Diamond</div>
        <div class="shape-item" draggable="true" data-shape="triangle"><span class="icon">▲</span>Triangle</div>
        <div class="shape-item" draggable="true" data-shape="note"><span class="icon">✎</span>Note</div>

        <hr style="border:none;border-top:1px solid #203b6b;margin:12px 0;">
        <button id="saveLocal"
          style="width:100%;padding:8px;border-radius:8px;background:transparent;border:1px solid var(--accent);color:var(--accent);font-weight:700;">Save
          to Local</button>
        <button id="loadLocal"
          style="width:100%;padding:8px;border-radius:8px;margin-top:8px;background:transparent;border:1px solid #7a9acd;color:#7a9acd;font-weight:700;">Load
          from Local</button>

        <input id="importFile" type="file" accept="application/json" style="display:none;">
        <button id="importBtn"
          style="width:100%;padding:8px;border-radius:8px;margin-top:8px;background:transparent;border:1px solid #7a9acd;color:#7a9acd;font-weight:700;">Import
          JSON</button>
        <button id="exportJson"
          style="width:100%;padding:8px;border-radius:8px;margin-top:8px;background:transparent;border:1px solid var(--accent);color:var(--accent);font-weight:700;">Export
          JSON</button>
      </aside>

      <section class="canvas-container" aria-label="Concept map canvas">
        <div id="grid"></div>
        <svg id="canvas-svg" tabindex="0"></svg>
      </section>

      <aside class="inspector side-panel" aria-label="Properties inspector" hidden>
        <h3 style="color:var(--accent);margin:0 0 12px 0;">Inspector</h3>
        <label for="insLabel">Label</label>
        <input id="insLabel" type="text" />

        <label for="insFillColor">Fill Color</label>
        <input id="insFillColor" type="color" value="#60a5fa" />

        <label for="insBorderColor">Border Color</label>
        <input id="insBorderColor" type="color" value="#2c4dab" />
        <label><input type="checkbox" id="insNoFill" /> No Fill (Transparent)</label>
        <label><input type="checkbox" id="insNoStroke" /> No Stroke (Transparent)</label>
        <label>Canvas Background:</label>
        <input type="color" id="canvasBgColor" value="#081333" />
        <input type="checkbox" id="canvasBgTransparent" /> Transparent


        <label for="insFontSize">Font Size</label>
        <select id="insFontSize">
          <option>12</option>
          <option>14</option>
          <option selected>16</option>
          <option>18</option>
          <option>20</option>
        </select>

        <label for="insFontWeight">Font Weight</label>
        <select id="insFontWeight">
          <option value="normal">Normal</option>
          <option value="bold">Bold</option>
        </select>

        <label for="insFontStyle">Font Style</label>
        <select id="insFontStyle">
          <option value="normal">Normal</option>
          <option value="italic">Italic</option>
        </select>

        <label for="insFontFamily">Font Family</label>
        <select id="insFontFamily">
          <option value="Arial">Arial</option>
          <option value="Courier New">Courier New</option>
          <option value="Georgia">Georgia</option>
          <option value="Times New Roman">Times New Roman</option>
          <option value="Verdana">Verdana</option>
        </select>
        <label for="insFontColor">Font Color</label>
        <input id="insFontColor" type="color" value="#e4ebff" />


        <label for="insBorderWidth">Border Width</label>
        <input id="insBorderWidth" type="number" value="2" min="1" max="8" />

        <label for="insOpacity">Opacity</label>
        <input id="insOpacity" type="number" step="0.05" value="1" min="0.1" max="1" />


        <hr style="border:none;border-top:1px solid #203b6b;margin:12px 0;">

        <button id="groupBtn"
          style="width:100%;padding:8px;border-radius:8px;background:transparent;border:1px solid var(--accent);color:var(--accent);font-weight:700;">Group
          Selected</button>
        <button id="ungroupBtn"
          style="width:100%;padding:8px;border-radius:8px;margin-top:8px;background:transparent;border:1px solid #7a9acd;color:#7a9acd;font-weight:700;">Ungroup</button>
      </aside>
    </main>
  </div>

  <!-- Context menu -->
  <div id="contextMenu" class="context-menu" role="menu" aria-hidden="true">
    <button id="ctxDelete">Delete</button>
    <button id="ctxDuplicate">Duplicate</button>
    <button id="ctxGroup">Group</button>
    <button id="ctxUngroup">Ungroup</button>
    <button id="ctxExportJson">Export JSON</button>
  </div>

  <script>
    (() => {
      // ---- Constants and state ----
      const svgNS = "http://www.w3.org/2000/svg";
      const GRID = 20;
      const canvasSvg = document.getElementById('canvas-svg');
      const canvasContainer = document.querySelector('.canvas-container');
      const inspector = document.querySelector('.inspector');
      const insLabel = document.getElementById('insLabel');
      const insFill = document.getElementById('insFillColor');
      const insStroke = document.getElementById('insBorderColor');
      const insFont = document.getElementById('insFontSize');
      const insStrokeW = document.getElementById('insBorderWidth');
      const insOpacity = document.getElementById('insOpacity');
      const applyStyleBtn = document.getElementById('applyStyle');
      const insFontColor = document.getElementById('insFontColor');

      // toolbar and controls
      const undoBtn = document.getElementById('undo');
      const redoBtn = document.getElementById('redo');
      const copyBtn = document.getElementById('copy');
      const pasteBtn = document.getElementById('paste');
      const duplicateBtn = document.getElementById('duplicate');
      const deleteBtn = document.getElementById('deleteSelected');
      const deleteBtn2 = document.getElementById('deleteSelectedBtn');
      const zoomInBtn = document.getElementById('zoomIn');
      const zoomOutBtn = document.getElementById('zoomOut');
      const fitBtn = document.getElementById('fit');
      const exportSvgBtn = document.getElementById('exportSvg');
      const exportPngBtn = document.getElementById('exportPng');
      const saveLocalBtn = document.getElementById('saveLocal');
      const loadLocalBtn = document.getElementById('loadLocal');
      const exportJsonBtn = document.getElementById('exportJson');
      const importInput = document.getElementById('importFile');
      const importBtn = document.getElementById('importBtn');

      const ctxMenu = document.getElementById('contextMenu');
      const ctxDelete = document.getElementById('ctxDelete');
      const ctxDuplicate = document.getElementById('ctxDuplicate');
      const ctxGroup = document.getElementById('ctxGroup');
      const ctxUngroup = document.getElementById('ctxUngroup');
      const ctxExportJson = document.getElementById('ctxExportJson');

      const insNoFill = document.getElementById('insNoFill');
      const insNoStroke = document.getElementById('insNoStroke');
      const canvasBgColorInput = document.getElementById('canvasBgColor');
      const canvasBgTransparent = document.getElementById('canvasBgTransparent');


      // state
      let shapes = [];          // shape objects
      let connectors = [];      // {id, from:{shapeId,anchor}, to:{shapeId,anchor}}
      let groups = [];          // {id, members: [shapeId,...]}
      let selected = [];        // selected shape ids
      let copiedShapes = [];    // copied shapes (cloned)
      let undoStack = [];
      let redoStack = [];
      let dragState = null;
      let zoomLevel = 1;
      let pan = { x: 0, y: 0 };
      let connectorDrag = null; // {connectorId, side:'from'|'to'}
      let lastRightClick = null; // keep target and coords

      // helpers
      function uuid() { return 'id-' + Math.random().toString(36).slice(2, 10); }
      function snap(v) { return Math.round(v / GRID) * GRID; }

      // snapshot (push state)
      function snapshot() {
        undoStack.push(JSON.stringify({ shapes: structuredClone(shapes), connectors: structuredClone(connectors), groups: structuredClone(groups) }));
        redoStack = [];
        updateUndoRedoButtons();
      }
      function updateUndoRedoButtons() {
        undoBtn.disabled = undoStack.length === 0;
        redoBtn.disabled = redoStack.length === 0;
      }
      function restore(stateStr) {
        const st = JSON.parse(stateStr);
        shapes = st.shapes;
        connectors = st.connectors;
        groups = st.groups || [];
        selected = [];
        render();
      }

      // palette drag fix: attach events to .shape-item
      document.querySelectorAll('.shape-item').forEach(item => {
        item.addEventListener('dragstart', e => {
          e.dataTransfer.setData('text/plain', item.dataset.shape);
        });
      });

      canvasContainer.addEventListener('dragover', e => { e.preventDefault(); });
      canvasContainer.addEventListener('drop', e => {
        e.preventDefault();
        const type = e.dataTransfer.getData('text/plain');
        if (!type) return;
        const rect = canvasSvg.getBoundingClientRect();
        const x = snap((e.clientX - rect.left) / zoomLevel - pan.x);
        const y = snap((e.clientY - rect.top) / zoomLevel - pan.y);
        addShape(type, x, y);
      });

      // ----- create shape -----
      function addShape(type, x = 80, y = 80) {
        const base = { w: 140, h: 70 };
        const sh = {
          id: uuid(), type, x, y,
          w: base.w, h: base.h, r: 0,
          text: type === 'note' ? 'Note' : type.toUpperCase(),
          fill: type === 'note' ? '#fffbe6' : '#60a5fa',
          stroke: '#2c4dab', fontSize: 16, strokeWidth: 2, opacity: 1,
        };
        shapes.push(sh);
        snapshot();
        render();
        return sh;
      }

      // ----- rendering -----
      function make(tag, attrs = {}, text) {
        const el = document.createElementNS(svgNS, tag);
        for (const k in attrs) if (attrs[k] !== undefined && attrs[k] !== null) el.setAttribute(k, attrs[k]);
        if (text !== undefined) el.textContent = text;
        return el;
      }

      function clearSvg() { canvasSvg.innerHTML = ''; }

      function findShapeAt(pointX, pointY) {
        return shapes.find(s => {
          return pointX >= s.x && pointX <= s.x + s.w && pointY >= s.y && pointY <= s.y + s.h;
        });
      }

      // anchor helpers: returns {x,y}
      function anchorPoint(shape, anchor = 'center') {
        switch (anchor) {
          case 'left': return { x: shape.x, y: shape.y + shape.h / 2 };
          case 'right': return { x: shape.x + shape.w, y: shape.y + shape.h / 2 };
          case 'top': return { x: shape.x + shape.w / 2, y: shape.y };
          case 'bottom': return { x: shape.x + shape.w / 2, y: shape.y + shape.h };
          default: return { x: shape.x + shape.w / 2, y: shape.y + shape.h / 2 };
        }
      }

      function updateInspectorNoFillStroke() {
        if (selected.length !== 1) return;
        const s = shapes.find(x => x.id === selected[0]);
        if (!s) return;
        insNoFill.checked = s.fill === 'transparent';
        insNoStroke.checked = s.stroke === 'transparent';
        insFill.disabled = insNoFill.checked;
        insStroke.disabled = insNoStroke.checked;

      }

      insNoFill.addEventListener('change', () => {
        if (selected.length !== 1) return;
        const s = shapes.find(x => x.id === selected[0]);
        if (!s) return;
        if (insNoFill.checked) {
          s.fill = 'transparent';
        } else {
          s.fill = insFill.value;
        }
        insFill.disabled = insNoFill.checked;
        snapshot();
        render();
      });

      insNoStroke.addEventListener('change', () => {
        if (selected.length !== 1) return;
        const s = shapes.find(x => x.id === selected[0]);
        if (!s) return;
        if (insNoStroke.checked) {
          s.stroke = 'transparent';
        } else {
          s.stroke = insStroke.value;
        }
        insStroke.disabled = insNoStroke.checked;
        snapshot();
        render();
      });

      // Also update color inputs to sync if user changes manually and checkbox is unchecked
      insFill.addEventListener('input', () => {
        if (insNoFill.checked) return;
        if (selected.length !== 1) return;
        const s = shapes.find(x => x.id === selected[0]);
        if (!s) return;
        s.fill = insFill.value;
        snapshot();
        render();
      });
      insStroke.addEventListener('input', () => {
        if (insNoStroke.checked) return;
        if (selected.length !== 1) return;
        const s = shapes.find(x => x.id === selected[0]);
        if (!s) return;
        s.stroke = insStroke.value;
        snapshot();
        render();
      });

      function nearestAnchor(shape, px, py) {
        const candidates = ['left', 'right', 'top', 'bottom', 'center'];
        let best = null; let bestD = Infinity;
        for (const a of candidates) {
          const p = anchorPoint(shape, a);
          const d = Math.hypot(p.x - px, p.y - py);
          if (d < bestD) { bestD = d; best = a; }
        }
        return best;
      }

      function render() {
        clearSvg();
        // defs
        const defs = make('defs');
        // arrow marker
        const marker = make('marker', { id: 'arrow', viewBox: '0 0 10 10', refX: 9, refY: 5, markerUnits: 'strokeWidth', markerWidth: 6, markerHeight: 6, orient: 'auto' });
        marker.appendChild(make('path', { d: 'M 0 0 L 10 5 L 0 10 z', fill: '#a9c7ff' }));
        defs.appendChild(marker);
        canvasSvg.appendChild(defs);

        // wrapper group with pan & zoom transform
        const root = make('g', { transform: `translate(${pan.x},${pan.y}) scale(${zoomLevel})` });
        canvasSvg.appendChild(root);

        // connectors (lines behind shapes)
        connectors.forEach(c => {
          const fromShape = shapes.find(s => s.id === c.from.shapeId);
          const toShape = shapes.find(s => s.id === c.to.shapeId);
          if (!fromShape || !toShape) return;
          const p1 = anchorPoint(fromShape, c.from.anchor);
          const p2 = anchorPoint(toShape, c.to.anchor);
          const line = make('line', { x1: p1.x, y1: p1.y, x2: p2.x, y2: p2.y, stroke: '#a9c7ff', 'stroke-width': 2, 'marker-end': 'url(#arrow)', 'data-id': c.id });
          line.addEventListener('mousedown', e => {
            // start dragging endpoint if ctrl-click on endpoint; otherwise ignore
            if (e.ctrlKey) {
              // decide which endpoint is closer
              const pt = screenToWorld(e.clientX, e.clientY);
              const d1 = Math.hypot(pt.x - p1.x, pt.y - p1.y);
              const d2 = Math.hypot(pt.x - p2.x, pt.y - p2.y);
              connectorDrag = { connectorId: c.id, side: d1 < d2 ? 'from' : 'to' };
              window.addEventListener('mousemove', onConnectorDrag);
              window.addEventListener('mouseup', onConnectorDrop);
              e.stopPropagation();
            }
          });
          root.appendChild(line);
        });

        // shapes
        shapes.forEach(s => {
          const g = make('g', { transform: `translate(${s.x},${s.y})`, 'data-id': s.id });
          // background depending on type
          let el;
          const common = { fill: s.fill, stroke: s.stroke, 'stroke-width': s.strokeWidth };
          switch (s.type) {
            case 'rect':
              el = make('rect', { width: s.w, height: s.h, rx: 12, ry: 12, ...common });
              break;
            case 'ellipse':
              el = make('ellipse', { cx: s.w / 2, cy: s.h / 2, rx: s.w / 2, ry: s.h / 2, ...common });
              break;
            case 'circle':
              el = make('circle', { cx: s.w / 2, cy: s.h / 2, r: Math.min(s.w, s.h) / 2, ...common });
              break;
            case 'diamond':
              el = make('polygon', { points: `${s.w / 2},0 ${s.w},${s.h / 2} ${s.w / 2},${s.h} 0,${s.h / 2}`, ...common });
              break;
            case 'triangle':
              el = make('polygon', { points: `${s.w / 2},0 ${s.w},${s.h} 0,${s.h}`, ...common });
              break;
            case 'note':
              el = make('rect', { width: s.w, height: s.h, rx: 6, ry: 6, fill: s.fill, stroke: s.stroke, 'stroke-width': s.strokeWidth });
              break;
            default:
              el = make('rect', { width: s.w, height: s.h, rx: 10, ry: 10, ...common });
          }
          el.style.cursor = 'grab';
          el.setAttribute('opacity', s.opacity);
          // events for selecting/draging shapes
          el.addEventListener('mousedown', e => shapeMouseDown(e, s));
          g.appendChild(el);

          // text
          const text = make('text', {
            x: s.w / 2,
            y: s.h / 2,
            'text-anchor': 'middle',
            'dominant-baseline': 'middle',
            'font-weight': s.fontWeight || 'normal',
            'font-style': s.fontStyle || 'normal',
            'font-family': s.fontFamily || 'Arial',
            'font-size': s.fontSize,
            fill: s.fontColor || (s.type === 'note' ? '#07162a' : '#e4ebff'),
            style: 'pointer-events:none;user-select:none;'
          });

          text.textContent = s.text;
          g.appendChild(text);

          // show selection outline + handles
          if (selected.includes(s.id)) {
            const outline = make('rect', { x: -8, y: -8, width: s.w + 16, height: s.h + 16, fill: 'none', stroke: 'var(--accent)', 'stroke-width': 2, 'stroke-dasharray': '6 4', 'pointer-events': 'none' });
            g.appendChild(outline);
            // handles (4 corners)
            const handles = [
              { cx: 0, cy: 0, cursor: 'nwse-resize', pos: 'nw' },
              { cx: s.w, cy: 0, cursor: 'nesw-resize', pos: 'ne' },
              { cx: 0, cy: s.h, cursor: 'nesw-resize', pos: 'sw' },
              { cx: s.w, cy: s.h, cursor: 'nwse-resize', pos: 'se' },
            ];
            handles.forEach(h => {
              const hv = make('rect', { x: h.cx - 6, y: h.cy - 6, width: 12, height: 12, class: 'handle', 'data-pos': h.pos });
              hv.style.cursor = h.cursor;
              hv.addEventListener('mousedown', e => handleMouseDown(e, s, h.pos));
              g.appendChild(hv);
            });
            // small "connector attach" spots (left/right/top/bottom)
            const attachSpots = [
              { x: -6, y: s.h / 2 - 6, pos: 'left' },
              { x: s.w - 6, y: s.h / 2 - 6, pos: 'right' },
              { x: s.w / 2 - 6, y: -6, pos: 'top' },
              { x: s.w / 2 - 6, y: s.h - 6, pos: 'bottom' },
            ];
            attachSpots.forEach(a => {
              const sp = make('rect', { x: a.x, y: a.y, width: 12, height: 12, rx: 3, ry: 3, fill: '#0b1b36', stroke: '#a9c7ff', 'data-anchor': a.pos });
              sp.addEventListener('mousedown', e => {
                // begin connector creation from this anchor
                e.stopPropagation();
                startConnectorDrag(s.id, a.pos, e);
              });
              g.appendChild(sp);
            });
          }

          root.appendChild(g);
        });

        // groups visualization? Could be added; for now groups are logical only.

        updateInspector();
      }

      // coordinate transforms
      function screenToWorld(clientX, clientY) {
        const rect = canvasSvg.getBoundingClientRect();
        const x = (clientX - rect.left) / zoomLevel - pan.x;
        const y = (clientY - rect.top) / zoomLevel - pan.y;
        return { x, y };
      }

      // ---- selection & dragging ----
      function shapeMouseDown(e, shape) {
        e.stopPropagation();
        const world = screenToWorld(e.clientX, e.clientY);

        // selection logic
        if (!e.shiftKey && !selected.includes(shape.id)) {
          selected = [shape.id];
        } else if (e.shiftKey) {
          // toggle
          if (selected.includes(shape.id)) selected = selected.filter(id => id !== shape.id);
          else selected.push(shape.id);
        }

        // prepare drag
        const origPositions = selected.map(id => {
          const s = shapes.find(x => x.id === id);
          return { id: s.id, x: s.x, y: s.y };
        });
        dragState = { type: 'move', startX: world.x, startY: world.y, origPositions };
        window.addEventListener('mousemove', onDrag);
        window.addEventListener('mouseup', onDrop);
        render();
      }

      function onDrag(e) {
        if (!dragState) return;
        const world = screenToWorld(e.clientX, e.clientY);
        if (dragState.type === 'move') {
          const dx = snap(world.x - dragState.startX);
          const dy = snap(world.y - dragState.startY);
          dragState.origPositions.forEach(p => {
            const s = shapes.find(x => x.id === p.id);
            if (s) { s.x = p.x + dx; s.y = p.y + dy; }
          });
          render();
        } else if (dragState.type === 'resize') {
          // handled by resize handler (we set dragState with resize info)
          const s = shapes.find(x => x.id === dragState.id);
          if (!s) return;
          const deltaX = world.x - dragState.startX;
          const deltaY = world.y - dragState.startY;
          // depending on handle pos
          let newX = dragState.base.x, newY = dragState.base.y, newW = dragState.base.w, newH = dragState.base.h;
          switch (dragState.pos) {
            case 'nw':
              newX = dragState.base.x + deltaX; newY = dragState.base.y + deltaY; newW = dragState.base.w - deltaX; newH = dragState.base.h - deltaY; break;
            case 'ne':
              newY = dragState.base.y + deltaY; newW = dragState.base.w + deltaX; newH = dragState.base.h - deltaY; break;
            case 'sw':
              newX = dragState.base.x + deltaX; newW = dragState.base.w - deltaX; newH = dragState.base.h + deltaY; break;
            case 'se':
              newW = dragState.base.w + deltaX; newH = dragState.base.h + deltaY; break;
          }
          // min size
          newW = Math.max(40, newW); newH = Math.max(30, newH);
          // snap
          newX = snap(newX); newY = snap(newY); newW = snap(newW); newH = snap(newH);
          s.x = newX; s.y = newY; s.w = newW; s.h = newH;
          render();
        }
      }

      function onDrop() {
        if (dragState) snapshot();
        dragState = null;
        window.removeEventListener('mousemove', onDrag);
        window.removeEventListener('mouseup', onDrop);
      }

      // resize handle events
      function handleMouseDown(e, shape, pos) {
        e.stopPropagation();
        const world = screenToWorld(e.clientX, e.clientY);
        dragState = { type: 'resize', id: shape.id, pos, startX: world.x, startY: world.y, base: { x: shape.x, y: shape.y, w: shape.w, h: shape.h } };
        window.addEventListener('mousemove', onDrag);
        window.addEventListener('mouseup', onDrop);
      }

      // connector creation via small anchor blocks
      function startConnectorDrag(shapeId, anchor, e) {
        // create a temp connector with to/from same initially
        const id = uuid();
        const conn = { id, from: { shapeId, anchor }, to: { shapeId, anchor } };
        connectors.push(conn);
        connectorDrag = { connectorId: id, side: 'to' };
        window.addEventListener('mousemove', onConnectorDrag);
        window.addEventListener('mouseup', onConnectorDrop);
        snapshot();
        render();
      }

      function onConnectorDrag(e) {
        if (!connectorDrag) return;
        const conn = connectors.find(c => c.id === connectorDrag.connectorId);
        if (!conn) return;
        const pt = screenToWorld(e.clientX, e.clientY);
        // dynamic: if hovering over shape, snap endpoint to nearest anchor on that shape
        const hit = findShapeAt(pt.x, pt.y);
        if (hit) {
          const anc = nearestAnchor(hit, pt.x, pt.y);
          if (connectorDrag.side === 'from') conn.from = { shapeId: hit.id, anchor: anc };
          else conn.to = { shapeId: hit.id, anchor: anc };
        } else {
          // create temporary floating anchor by using a virtual shape with id null and anchor center coordinates encoded
          // we'll store shapeId:null and anchor:{x,y} as custom style
          if (connectorDrag.side === 'from') conn.from = { shapeId: null, anchor: { x: pt.x, y: pt.y } };
          else conn.to = { shapeId: null, anchor: { x: pt.x, y: pt.y } };
        }
        render();
      }

      function onConnectorDrop(e) {
        if (!connectorDrag) return;
        const conn = connectors.find(c => c.id === connectorDrag.connectorId);
        if (!conn) { connectorDrag = null; return; }
        const pt = screenToWorld(e.clientX, e.clientY);
        const hit = findShapeAt(pt.x, pt.y);
        if (hit) {
          const anc = nearestAnchor(hit, pt.x, pt.y);
          if (connectorDrag.side === 'from') conn.from = { shapeId: hit.id, anchor: anc };
          else conn.to = { shapeId: hit.id, anchor: anc };
        } else {
          // if ended not on a shape, remove connector
          connectors = connectors.filter(c => c.id !== conn.id);
        }
        connectorDrag = null;
        window.removeEventListener('mousemove', onConnectorDrag);
        window.removeEventListener('mouseup', onConnectorDrop);
        snapshot();
        render();
      }

      // ----- inspector -----
      function updateInspector() {
        if (selected.length === 1) {
          inspector.hidden = false;
          const s = shapes.find(x => x.id === selected[0]);
          if (!s) return;
          insLabel.value = s.text;
          insFill.value = s.fill === 'transparent' ? '#ffffff' : s.fill;
          insStroke.value = s.stroke === 'transparent' ? '#2c4dab' : s.stroke;
          insFont.value = s.fontSize;
          insStrokeW.value = s.strokeWidth;
          insOpacity.value = s.opacity;
          insFontColor.value = s.fontColor || '#e4ebff';

          updateInspectorNoFillStroke();
        } else {
          inspector.hidden = true;
        }
      }
      function updateCanvasBackground() {
        if (canvasBgTransparent.checked) {
          canvasContainer.style.background = 'transparent';
        } else {
          canvasContainer.style.background = canvasBgColorInput.value;
        }
      }

      canvasBgColorInput.addEventListener('input', () => {
        if (!canvasBgTransparent.checked) {
          updateCanvasBackground();
        }
      });

      canvasBgTransparent.addEventListener('change', updateCanvasBackground);

      // Initialize canvas background at startup
      updateCanvasBackground();
      function applyInspectorChanges() {
        if (selected.length !== 1) return;
        const s = shapes.find(x => x.id === selected[0]);
        if (!s) return;
        s.text = insLabel.value;
        s.fill = insNoFill.checked ? 'transparent' : insFill.value;
        s.stroke = insNoStroke.checked ? 'transparent' : insStroke.value;
        s.fontSize = parseInt(insFont.value);
        s.fontWeight = insFontWeight.value;
        s.fontStyle = insFontStyle.value;
        s.fontFamily = insFontFamily.value;
        s.fontColor = insFontColor.value; // set font color
        s.strokeWidth = parseInt(insStrokeW.value);
        s.opacity = parseFloat(insOpacity.value);
        render();
        snapshot();
      }

      insFontColor.addEventListener('input', applyInspectorChanges);


      insLabel.addEventListener('input', applyInspectorChanges);
      insFill.addEventListener('input', applyInspectorChanges);
      insStroke.addEventListener('input', applyInspectorChanges);
      insFont.addEventListener('change', applyInspectorChanges);
      insFontWeight.addEventListener('change', applyInspectorChanges);
      insFontStyle.addEventListener('change', applyInspectorChanges);
      insFontFamily.addEventListener('change', applyInspectorChanges);
      insStrokeW.addEventListener('input', applyInspectorChanges);
      insOpacity.addEventListener('input', applyInspectorChanges);


      insLabel.addEventListener('input', applyInspectorChanges);
      insFill.addEventListener('input', applyInspectorChanges);
      insStroke.addEventListener('input', applyInspectorChanges);
      insFont.addEventListener('change', applyInspectorChanges);
      insStrokeW.addEventListener('input', applyInspectorChanges);
      insOpacity.addEventListener('input', applyInspectorChanges);


      // delete
      function deleteSelectedShapes() {
        if (selected.length === 0) return;
        snapshot();
        shapes = shapes.filter(s => !selected.includes(s.id));
        connectors = connectors.filter(c => !selected.includes(c.from.shapeId) && !selected.includes(c.to.shapeId));
        // also remove groups entries that reference removed shapes
        groups = groups.map(g => ({ id: g.id, members: g.members.filter(m => shapes.find(s => s.id === m)) })).filter(g => g.members.length > 0);
        selected = [];
        render();
      }
      deleteBtn.addEventListener('click', deleteSelectedShapes);
      deleteBtn2.addEventListener('click', deleteSelectedShapes);
      ctxDelete.addEventListener('click', () => { deleteSelectedShapes(); hideContextMenu(); });

      // copy/paste
      copyBtn.addEventListener('click', () => { copiedShapes = shapes.filter(s => selected.includes(s.id)).map(s => structuredClone(s)); });
      pasteBtn.addEventListener('click', () => {
        if (!copiedShapes.length) return;
        snapshot();
        const newIds = [];
        copiedShapes.forEach(cs => {
          const copy = structuredClone(cs);
          copy.id = uuid(); copy.x += 20; copy.y += 20;
          shapes.push(copy);
          newIds.push(copy.id);
        });
        selected = newIds;
        render();
      });

      // duplicate
      duplicateBtn.addEventListener('click', () => {
        if (!selected.length) return;
        snapshot();
        const toCopy = shapes.filter(s => selected.includes(s.id));
        const newIds = [];
        toCopy.forEach(s => {
          const copy = structuredClone(s);
          copy.id = uuid(); copy.x += 20; copy.y += 20;
          shapes.push(copy); newIds.push(copy.id);
        });
        selected = newIds; render();
      });
      ctxDuplicate.addEventListener('click', () => { duplicateBtn.click(); hideContextMenu(); });

      // grouping
      document.getElementById('groupBtn').addEventListener('click', () => { groupSelected(); });
      document.getElementById('ungroupBtn').addEventListener('click', () => { ungroupSelected(); });
      ctxGroup.addEventListener('click', () => { groupSelected(); hideContextMenu(); });
      ctxUngroup.addEventListener('click', () => { ungroupSelected(); hideContextMenu(); });

      function groupSelected() {
        if (selected.length < 2) return;
        snapshot();
        const gid = uuid();
        groups.push({ id: gid, members: [...selected] });
        // represent group as selecting its members
        render();
      }
      function ungroupSelected() {
        // remove groups that are exactly the selected
        snapshot();
        groups = groups.filter(g => {
          const same = g.members.length === selected.length && g.members.every(m => selected.includes(m));
          return !same;
        });
        render();
      }

      // keyboard shortcuts
      window.addEventListener('keydown', e => {
        const ctrl = e.ctrlKey || e.metaKey;
        if (ctrl && e.key.toLowerCase() === 'z') { // undo
          e.preventDefault();
          if (!undoStack.length) return;
          redoStack.push(JSON.stringify({ shapes: structuredClone(shapes), connectors: structuredClone(connectors), groups: structuredClone(groups) }));
          const prev = undoStack.pop(); restore(prev);
        } else if (ctrl && (e.key.toLowerCase() === 'y' || (e.shiftKey && e.key.toLowerCase() === 'z'))) {
          e.preventDefault();
          if (!redoStack.length) return;
          undoStack.push(JSON.stringify({ shapes: structuredClone(shapes), connectors: structuredClone(connectors), groups: structuredClone(groups) }));
          const next = redoStack.pop(); restore(next);
        } else if (e.key === 'Delete') {
          e.preventDefault();
          deleteSelectedShapes();
        } else if (ctrl && e.key.toLowerCase() === 'c') {
          copyBtn.click();
        } else if (ctrl && e.key.toLowerCase() === 'v') {
          pasteBtn.click();
        }
      });

      // undo/redo buttons
      undoBtn.addEventListener('click', () => {
        if (!undoStack.length) return;
        redoStack.push(JSON.stringify({ shapes: structuredClone(shapes), connectors: structuredClone(connectors), groups: structuredClone(groups) }));
        const prev = undoStack.pop(); restore(prev);
      });
      redoBtn.addEventListener('click', () => {
        if (!redoStack.length) return;
        undoStack.push(JSON.stringify({ shapes: structuredClone(shapes), connectors: structuredClone(connectors), groups: structuredClone(groups) }));
        const next = redoStack.pop(); restore(next);
      });

      // zoom
      zoomInBtn.addEventListener('click', () => { zoomLevel *= 1.2; applyTransform(); });
      zoomOutBtn.addEventListener('click', () => { zoomLevel /= 1.2; applyTransform(); });
      fitBtn.addEventListener('click', () => { zoomLevel = 1; pan = { x: 0, y: 0 }; applyTransform(); render(); });
      function applyTransform() { canvasSvg.style.transformOrigin = '0 0'; canvasSvg.style.transform = `scale(${zoomLevel})`; render(); }

      // simple pan by dragging background with spacebar pressed
      let panning = false, panLast = null;
      canvasSvg.addEventListener('mousedown', e => {
        // right click is context menu handled separately
        if (e.button === 1 || (e.button === 0 && e.spaceKey)) { } // reserved
      });

      // background deselect
      canvasSvg.addEventListener('mousedown', e => {
        if (e.button === 0 && e.target === canvasSvg) { selected = []; render(); }
      });

      // export SVG
      exportSvgBtn.addEventListener('click', () => {
        const svgBlob = new Blob([canvasSvg.outerHTML], { type: 'image/svg+xml' });
        const url = URL.createObjectURL(svgBlob);
        const a = document.createElement('a');
        a.href = url; a.download = 'concept-map.svg'; document.body.appendChild(a); a.click(); document.body.removeChild(a);
        URL.revokeObjectURL(url);
      });

      // export PNG (rasterize)
      exportPngBtn.addEventListener('click', () => {
        const xml = new XMLSerializer().serializeToString(canvasSvg);
        const svg64 = btoa(unescape(encodeURIComponent(xml)));
        const img = new Image();
        img.onload = () => {
          const canvas = document.createElement('canvas');
          const rect = canvasSvg.getBoundingClientRect();
          canvas.width = rect.width * 2; canvas.height = rect.height * 2;
          const ctx = canvas.getContext('2d');
          ctx.fillStyle = '#0c173a'; ctx.fillRect(0, 0, canvas.width, canvas.height);
          ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
          const png = canvas.toDataURL('image/png');
          const a = document.createElement('a'); a.href = png; a.download = 'concept-map.png'; document.body.appendChild(a); a.click(); document.body.removeChild(a);
        };
        img.src = 'data:image/svg+xml;base64,' + btoa(unescape(encodeURIComponent(xml)));
      });

      // Save/load JSON (localStorage)
      saveLocalBtn.addEventListener('click', () => {
        const data = { shapes, connectors, groups };
        localStorage.setItem('concept_map_v1', JSON.stringify(data));
        alert('Saved to localStorage.');
      });
      loadLocalBtn.addEventListener('click', () => {
        const raw = localStorage.getItem('concept_map_v1');
        if (!raw) { alert('No saved map found.'); return; }
        const obj = JSON.parse(raw);
        shapes = obj.shapes || []; connectors = obj.connectors || []; groups = obj.groups || [];
        selected = []; snapshot(); render();
      });

      // Export JSON file
      exportJsonBtn.addEventListener('click', () => {
        const data = { shapes, connectors, groups };
        const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download = 'concept-map.json'; document.body.appendChild(a); a.click(); document.body.removeChild(a);
        URL.revokeObjectURL(url);
      });

      // Import JSON
      importBtn.addEventListener('click', () => importInput.click());
      importInput.addEventListener('change', (ev) => {
        const file = ev.target.files[0]; if (!file) return;
        const reader = new FileReader();
        reader.onload = () => {
          try {
            const obj = JSON.parse(reader.result);
            shapes = obj.shapes || []; connectors = obj.connectors || []; groups = obj.groups || [];
            selected = []; snapshot(); render();
            alert('Imported successfully.');
          } catch (err) { alert('Invalid JSON file.'); }
        };
        reader.readAsText(file);
      });

      // context menu
      canvasSvg.addEventListener('contextmenu', e => {
        e.preventDefault();
        const world = screenToWorld(e.clientX, e.clientY);
        const hit = findShapeAt(world.x, world.y);
        lastRightClick = { target: hit, x: e.clientX, y: e.clientY };
        // show context depending on whether shape under cursor
        ctxGroup.disabled = !(selected.length > 1);
        ctxUngroup.disabled = !(groups.length > 0);
        showContextMenu(e.clientX, e.clientY);
      });

      function showContextMenu(x, y) {
        ctxMenu.style.left = x + 'px'; ctxMenu.style.top = y + 'px'; ctxMenu.style.display = 'block';
        setTimeout(() => ctxMenu.setAttribute('aria-hidden', 'false'), 10);
      }
      function hideContextMenu() { ctxMenu.style.display = 'none'; ctxMenu.setAttribute('aria-hidden', 'true'); }

      // context menu actions
      ctxDelete.addEventListener('click', () => { deleteSelectedShapes(); hideContextMenu(); });
      ctxExportJson.addEventListener('click', () => { exportJsonBtn.click(); hideContextMenu(); });

      // hide menu on click elsewhere
      window.addEventListener('click', (e) => { if (!ctxMenu.contains(e.target)) hideContextMenu(); });

      // helper: duplicate by id list
      function duplicateByIds(ids) {
        snapshot();
        const newIds = [];
        ids.forEach(id => {
          const s = shapes.find(x => x.id === id);
          if (!s) return;
          const copy = structuredClone(s);
          copy.id = uuid(); copy.x += 20; copy.y += 20;
          shapes.push(copy); newIds.push(copy.id);
        });
        selected = newIds; render();
      }

      // context menu "duplicate" uses current selection
      ctxDuplicate.addEventListener('click', () => { duplicateByIds(selected); hideContextMenu(); });

      // ----- simple initial data + render -----
      // initial shapes
      addShape('rect', 40, 40);
      addShape('ellipse', 240, 120);
      addShape('note', 480, 70);
      undoStack = []; redoStack = []; // clear initial history (we already pushed snapshots in addShape)
      snapshot();
      render();

      // utility: clicking on canvas to start connector (Ctrl+click on shape handled by anchors)
      canvasSvg.addEventListener('click', e => {
        // allow Ctrl+click to start a quick connector by clicking two shapes (legacy support)
        if (!e.ctrlKey) return;
        const world = screenToWorld(e.clientX, e.clientY);
        const hit = findShapeAt(world.x, world.y);
        if (!hit) return;
        if (!window._connectorQuickStart) { window._connectorQuickStart = hit.id; } else {
          const fromId = window._connectorQuickStart; const toId = hit.id;
          connectors.push({ id: uuid(), from: { shapeId: fromId, anchor: 'center' }, to: { shapeId: toId, anchor: 'center' } });
          window._connectorQuickStart = null; snapshot(); render();
        }
      });

      // helper to ensure connectors stored with consistent anchor format (normalize)
      function normalizeConnectors() {
        // nothing for now; reserved
      }

      // small improvements: click on canvas with Escape to clear selection
      window.addEventListener('keydown', e => { if (e.key === 'Escape') { selected = []; render(); hideContextMenu(); } });

      // make selection via mouse drag (marquee) could be added later

      // prevent accidental drag image ghost
      window.addEventListener('dragstart', e => { e.dataTransfer.setDragImage(document.createElement('img'), 0, 0); }, true);

      // Right now connectors referencing shapeId:null may exist (floating) — that's okay until user attaches or they get removed on drop.

    })();
  </script>
</body>

</html>
